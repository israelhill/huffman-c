
<!-- saved from url=(0108)https://blackboard.case.edu/bbcswebdav/pid-1145291-dt-content-rid-2950228_1/courses/eecs345_hsc21_2/hw2.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>EECS 345: Programming Exercise 2</title>
</head>

<body>
<h2>EECS 345: Programming Language Concepts</h2>
<h2>Programming Exercise 2</h2>
<h3>Due Friday, February 20</h3>

<p>For questions 1-8, write Scheme definitions for the following functions using
tail recursion and continuation passing style
(CPS). The continuation argument should be the last argument. For example, if
you were asked to write factorial, the ''normal'' recursive function is:
</p><pre>(define factorial
  (lambda (n)
    (if (zero? n)
        1
        (* n (factorial (- n 1))))))
</pre>
and so your answer should be
<pre>(define factorial-cps
  (lambda (n return)
    (if (zero? n)
        (return 1)
        (factorial-cps (- n 1) (lambda (v) (return (* n v)))))))
</pre><p></p>

<p>You do not have to convert simple scheme built-in non-recursive functions like <tt>null?</tt>,
<tt>eq?</tt>, <tt>list?</tt>, <tt>number?</tt>, <tt>car</tt>, <tt>cons</tt>, <tt>cdr</tt>, <tt>list</tt> to 
CPS, but all other helper functions you create should be in CPS.</p>
<p>Try to write these using no helper functions other than the other functions in this homework.</p>

<ol>

<li><tt>multiplyby</tt> takes a number and a list of numbers and returns a list that is the input list with each element multiplied by the input number.<br>
<em>You can write this function without any helper functions.</em><br>
<pre>&gt; (multiplyby 5 '(1 2 3 4 10 11))
(5 10 15 20 50 55)
</pre></li>

<li><tt>crossmultiply</tt> takes two lists of numbers, each list represents a vector.  
Returns the <em>outer product</em> of the two vectors.  The outer product is a matrix (a list of lists) and each list is the result of multiplying the
second list by the corresponding value of the first list.<br>
<pre>&gt; (crossmultiply '(1 2 3) '(3 0 2))
((3 0 2) (6 0 4) (9 0 6))
&gt; (crossmultiply '(8 -1 4 3) '(3 1))
((24 8) (-3 -1) (12 4) (9 3))
</pre></li>

<li><tt>maxnumber</tt> takes a list of numbers that contains at least one number and returns the largest number in the list.<br>
<em>You can write this function without any helper functions.</em><br>
<pre>&gt; (maxnumber '(3 1 5 2 7 5 3 8 1 2))
8
</pre></li>

<li><tt>partialsums*</tt> takes a list that may contain sublists.  The output should have the same list structure as the input, but the car of each list (and each sublist) should be the sum of all numbers in that list.
There should be no other values in the list.<br>
<em>You can write this function without any helper functions.</em><br>
<pre>&gt; (partialsums* '(1 a 2 b))
(3)
&gt; (partialsums* '((1) (2) (3)))
(6 (1) (2) (3))
&gt; (partialsums* '((1 2) (10 20) (100 200)))
(333 (3) (30) (300))
&gt; (partialsums* '(1 a (10 20 x y) c 2 (x y z) (a b 1 (c 200 d))))
(234 (30) (0) (201 (200)))
</pre></li>

<li><tt>trimatoms</tt> takes a list, possibly containing sublists, and a list of atoms.  It returns the list of atoms with the first <em>k</em> atoms of the list removed where <em>k</em> is the number of non-null atoms in the first list.<br>
<em>You can write this function without any helper functions.</em><br>
<pre>&gt; (trimatoms '(a b c) '(1 2 3 4))
(4)
&gt; (trimatoms '(((a)) (b ((c)))) '(1 2 3 4 5))
(4 5)
&gt; (trimatoms '(((a)) () () (b ((c)))) '(1 2 3 4 5))
(4 5)
</pre></li>

<li><tt>exchange</tt> takes a list (possibly containing sublists) and a list of atoms.  You may assume that both lists contain the same number of non-null atoms.
The output should be identical to the first list except that the atoms of the list should be the same as the atoms of the second list, in order. <br>
<pre>&gt; (exchange '(((a)) (b ((c)))) '(1 2 3))
(((1)) (2 ((3))))
&gt; (exchange '(((() a) b) c) '(1 2 3))
(((() 1) 2) 3)
</pre></li>

<li><tt>removesubsequence*</tt> 
 takes a list of atoms and a general list.  The first list is a <em>subsequence</em> of the second list.  The method should return the second list
with the first occurence of the subsequence removed.  So, if the first list is <tt>'(a b c)</tt>, the first <tt>a</tt> if the second list is removed, the first <tt>b</tt>
that appears after the removed <tt>a</tt> is removed, and the first <tt>c</tt> that appears after the removed <tt>b</tt> is removed - no matter how deep the atoms are nested.<br>
<pre>&gt; (removesubsequence* '(a b) '(w (x b) ((a) ((y z))) b) (lambda (v1 v2) v2))
(w (x b) (() ((y z))))
</pre>
As a hint, you need to keep track of two values between recursive calls.  So use two values in the continuation function: <tt>(removesubsequence* '(a b) '(w (x b) ((a) ((y z))) b) (lambda (v1 v2) v2))</tt></li>

<li>
The function <tt>split</tt> takes a list and returns a list containing two sublists, the first with
the elements at the odd indices and the second with the elements at the even indeces (assuming the first element is at index 1:
Try writing this using only two cases: <tt>(null? l)</tt> and <tt>else</tt>.  You should do something similar to the 
<tt>removesubsequence*</tt> where you keep track of two values and use a different continuation function.
<pre>&gt; (split '())
(()())
&gt; (split '(1)) 
((1)())
&gt; (split '(1 2 3 4 5)) 
((1 3 5) (2 4))
</pre>
</li>

     
<li><strong>Write the following function without external helper functions or additional parameters.</strong>  
You may use <tt>letrec</tt> to create an internal helper function that uses continuation passing style.
<br>
The function <tt>suffix</tt> takes an atom and a list and returns a list containing all elements
that occur <em>after</em> the last occurrence of the atom.
<pre>(suffix 'x '(a b c))  ==&gt; (a b c)
(suffix 'x '(a b x c d x e f)) ==&gt; (e f)
</pre>
</li>

<li><strong>Write a second version of suffix that uses <tt>call/cc</tt> instead of the "normal" continuation passing style.</strong>
You may not use external helper functions or additional parameters, but you may use <tt>letrec</tt>.
<pre>(suffix2 'x '(a b c))  ==&gt; (a b c)
(suffix2 'x '(a b x c d x e f)) ==&gt; (e f)
</pre>
</li>

</ol>



</body></html>